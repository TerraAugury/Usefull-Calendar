import fs from 'node:fs/promises'
import path from 'node:path'
import https from 'node:https'
import { fileURLToPath } from 'node:url'

const AIRPORTS_CSV_URL =
  'https://davidmegginson.github.io/ourairports-data/airports.csv'
const COUNTRIES_CSV_URL =
  'https://davidmegginson.github.io/ourairports-data/countries.csv'
const AIRPORTS_JSON_URL =
  'https://raw.githubusercontent.com/mwgg/Airports/master/airports.json'
const TWEMOJI_BASE_URL =
  'https://raw.githubusercontent.com/twitter/twemoji/master/assets/svg/'

function fetchText(url) {
  if (typeof fetch === 'function') {
    return fetch(url).then((response) => {
      if (!response.ok) {
        throw new Error(`Failed to fetch ${url}: ${response.status}`)
      }
      return response.text()
    })
  }
  return new Promise((resolve, reject) => {
    https
      .get(url, (res) => {
        if (res.statusCode !== 200) {
          reject(new Error(`Failed to fetch ${url}: ${res.statusCode}`))
          res.resume()
          return
        }
        let data = ''
        res.setEncoding('utf8')
        res.on('data', (chunk) => {
          data += chunk
        })
        res.on('end', () => resolve(data))
      })
      .on('error', reject)
  })
}

function parseCSVLine(line) {
  const values = []
  let current = ''
  let inQuotes = false
  for (let i = 0; i < line.length; i += 1) {
    const char = line[i]
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"'
        i += 1
      } else {
        inQuotes = !inQuotes
      }
    } else if (char === ',' && !inQuotes) {
      values.push(current)
      current = ''
    } else {
      current += char
    }
  }
  values.push(current)
  return values
}

function parseCSV(text) {
  const lines = text.split(/\r?\n/).filter((line) => line.trim() !== '')
  if (lines.length === 0) return []
  const headers = parseCSVLine(lines[0]).map((header) => header.trim())
  return lines.slice(1).map((line) => {
    const values = parseCSVLine(line)
    const record = {}
    headers.forEach((header, index) => {
      record[header] = values[index] ?? ''
    })
    return record
  })
}

function buildCountryMap(countriesCsv) {
  const countries = parseCSV(countriesCsv)
  const map = new Map()
  countries.forEach((country) => {
    const code = (country.code ?? '').trim().toUpperCase()
    const name = (country.name ?? '').trim()
    if (code && name) {
      map.set(code, name)
    }
  })
  return map
}

function buildAirportsMap(airportsCsv, countriesMap) {
  const airports = parseCSV(airportsCsv)
  const map = new Map()
  airports.forEach((airport) => {
    const scheduled = (airport.scheduled_service ?? '').trim().toLowerCase()
    if (scheduled !== 'yes') return
    const iata = (airport.iata_code ?? '').trim().toUpperCase()
    if (!iata) return
    const continent = (airport.continent ?? '').trim().toUpperCase()
    const countryCode = (airport.iso_country ?? '').trim().toUpperCase()
    const include =
      (continent === 'EU' && scheduled === 'yes') ||
      (countryCode === 'CY' && scheduled === 'yes')
    if (!include) return
    const countryName = countriesMap.get(countryCode) ?? 'Unknown'
    map.set(iata, { countryCode: countryCode || 'UN', countryName })
  })
  return map
}

function buildTimeZoneMap(airportsJson) {
  const data = JSON.parse(airportsJson)
  const map = new Map()
  Object.values(data).forEach((airport) => {
    if (!airport || typeof airport !== 'object') return
    const iata = typeof airport.iata === 'string' ? airport.iata.trim() : ''
    if (!iata) return
    const timeZone = typeof airport.tz === 'string' ? airport.tz.trim() : ''
    map.set(iata.toUpperCase(), timeZone || null)
  })
  return map
}

function applyCyprusOverrides(map) {
  const overrides = {
    LCA: { countryCode: 'CY', countryName: 'Cyprus', timeZone: 'Asia/Nicosia' },
    PFO: { countryCode: 'CY', countryName: 'Cyprus', timeZone: 'Asia/Nicosia' },
    ECN: { countryCode: 'CY', countryName: 'Cyprus', timeZone: 'Asia/Nicosia' },
  }
  Object.entries(overrides).forEach(([iata, info]) => {
    const current = map.get(iata)
    if (!current) {
      map.set(iata, info)
      return
    }
    map.set(iata, { ...current, ...info, timeZone: info.timeZone })
  })
}

function buildOutput(airports) {
  const sorted = Array.from(airports.entries()).sort(([a], [b]) =>
    a.localeCompare(b),
  )
  const lines = []
  lines.push(
    '// This file is auto-generated by scripts/generate-airports.mjs.',
  )
  lines.push(
    '// Sources: OurAirports (public domain) and mwgg/Airports (MIT).',
  )
  lines.push('// Do not edit manually.')
  lines.push('')
  lines.push('export const AIRPORTS = {')
  sorted.forEach(([iata, info]) => {
    const countryName = JSON.stringify(info.countryName ?? 'Unknown')
    const timeZone = info.timeZone ? `"${info.timeZone}"` : 'null'
    lines.push(
      `  "${iata}": { countryCode: "${info.countryCode}", countryName: ${countryName}, timeZone: ${timeZone} },`,
    )
  })
  lines.push('}')
  lines.push('')
  return lines.join('\n')
}

function buildFlagCodepoints(code) {
  return code
    .toUpperCase()
    .split('')
    .map((char) => (0x1f1e6 + char.charCodeAt(0) - 65).toString(16))
    .join('-')
}

async function fetchFlagSvg(code) {
  const codepoints = buildFlagCodepoints(code)
  const url = `${TWEMOJI_BASE_URL}${codepoints}.svg`
  try {
    return await fetchText(url)
  } catch {
    return null
  }
}

function buildFlagOutput(flags) {
  const sorted = Array.from(flags.entries()).sort(([a], [b]) =>
    a.localeCompare(b),
  )
  const lines = []
  lines.push('// This file is auto-generated by scripts/generate-airports.mjs.')
  lines.push('// Flag emojis sourced from Twemoji (CC BY 4.0).')
  lines.push('// Do not edit manually.')
  lines.push('')
  lines.push('export const FLAG_SVGS = {')
  sorted.forEach(([code, data]) => {
    lines.push(`  "${code}": "${data}",`)
  })
  lines.push('}')
  lines.push('')
  return lines.join('\n')
}

async function main() {
  const [airportsCsv, countriesCsv, airportsJson] = await Promise.all([
    fetchText(AIRPORTS_CSV_URL),
    fetchText(COUNTRIES_CSV_URL),
    fetchText(AIRPORTS_JSON_URL),
  ])

  const countriesMap = buildCountryMap(countriesCsv)
  const airportsMap = buildAirportsMap(airportsCsv, countriesMap)
  const timeZoneMap = buildTimeZoneMap(airportsJson)

  const merged = new Map()
  airportsMap.forEach((info, iata) => {
    const timeZone = timeZoneMap.get(iata) ?? null
    merged.set(iata, { ...info, timeZone })
  })

  applyCyprusOverrides(merged)

  let missingTimeZone = 0
  merged.forEach((info) => {
    if (!info.timeZone) missingTimeZone += 1
  })

  const output = buildOutput(merged)
  const __dirname = path.dirname(fileURLToPath(import.meta.url))
  const outputPath = path.resolve(__dirname, '../src/data/airports.generated.js')
  await fs.mkdir(path.dirname(outputPath), { recursive: true })
  await fs.writeFile(outputPath, output, 'utf8')

  const countryCodes = Array.from(
    new Set(
      Array.from(merged.values())
        .map((info) => info.countryCode)
        .filter((code) => code && code !== 'UN'),
    ),
  ).sort((a, b) => a.localeCompare(b))

  const flagMap = new Map()
  let missingFlags = 0
  for (const code of countryCodes) {
    const svg = await fetchFlagSvg(code)
    if (!svg) {
      missingFlags += 1
      continue
    }
    const base64 = Buffer.from(svg, 'utf8').toString('base64')
    flagMap.set(code, `data:image/svg+xml;base64,${base64}`)
  }
  const flagOutput = buildFlagOutput(flagMap)
  const flagOutputPath = path.resolve(__dirname, '../src/data/flags.generated.js')
  await fs.writeFile(flagOutputPath, flagOutput, 'utf8')

  console.log(`Generated airports: ${merged.size}`)
  console.log(`Missing time zones: ${missingTimeZone}`)
  console.log(`Generated flags: ${flagMap.size}`)
  console.log(`Missing flags: ${missingFlags}`)
}

main().catch((error) => {
  console.error(error)
  process.exit(1)
})
